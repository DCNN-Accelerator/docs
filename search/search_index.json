{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Convolutional Neural Network Accelerator This document describes the architecture and implementation for an end-to-end 2D convolution acceleration system, targeting applications such as image filtering and deep convolutional neural networks. The goal is to make our work and design understandable for anyone. Project Overview Deep Convolutional Neural Networks (DCNNs) have made significant progress in approaching a wide range of problems in the general area of computer vision. However, they generally require enormous computational resources and are therefore difficult to deploy in real-time systems. To address this problem, we designed a system for accelerating the core operations required by DCNNs, by using a low-cost Field Programmable Gate Array (FPGA) platform. Our team designed an end-to-end accelerator platform, including a PC running Linux, an FPGA board and PC-to-FPGA communication via serial data (over USB). We designed a hardwired convolution processor using custom fixed-point multipliers, and a software handler for sending and reconstructing images. Using custom Verilog/VHDL RTL descriptions and C++ software, we aim to exploit the parallelism inherent to FPGAs for high-speed acceleration. Project Website Check out our website here for more information about our project.","title":"Home"},{"location":"#convolutional-neural-network-accelerator","text":"This document describes the architecture and implementation for an end-to-end 2D convolution acceleration system, targeting applications such as image filtering and deep convolutional neural networks. The goal is to make our work and design understandable for anyone.","title":"Convolutional Neural Network Accelerator"},{"location":"#project-overview","text":"Deep Convolutional Neural Networks (DCNNs) have made significant progress in approaching a wide range of problems in the general area of computer vision. However, they generally require enormous computational resources and are therefore difficult to deploy in real-time systems. To address this problem, we designed a system for accelerating the core operations required by DCNNs, by using a low-cost Field Programmable Gate Array (FPGA) platform. Our team designed an end-to-end accelerator platform, including a PC running Linux, an FPGA board and PC-to-FPGA communication via serial data (over USB). We designed a hardwired convolution processor using custom fixed-point multipliers, and a software handler for sending and reconstructing images. Using custom Verilog/VHDL RTL descriptions and C++ software, we aim to exploit the parallelism inherent to FPGAs for high-speed acceleration.","title":"Project Overview"},{"location":"#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"about/","text":"More Information For more information about neural networks, convolutions, and the future of artificial intelligence, check out some of the resources below. A Comprehensive Guide to Convolutional Neural Networks This easy to follow guide provides helpful visuals and description about the main components of convolutional neural networks. Machine Learning Guide Hosted through a GitHub repository, this site provides brief visual explanations of machine learning concepts with diagrams, code examples and links to other resources. Project Website Check out our website here for more information about our project.","title":"About"},{"location":"about/#more-information","text":"For more information about neural networks, convolutions, and the future of artificial intelligence, check out some of the resources below.","title":"More Information"},{"location":"about/#a-comprehensive-guide-to-convolutional-neural-networks","text":"This easy to follow guide provides helpful visuals and description about the main components of convolutional neural networks.","title":"A Comprehensive Guide to Convolutional Neural Networks"},{"location":"about/#machine-learning-guide","text":"Hosted through a GitHub repository, this site provides brief visual explanations of machine learning concepts with diagrams, code examples and links to other resources.","title":"Machine Learning Guide"},{"location":"about/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"build_your_own/","text":"Build Your Own DCNN The following document describes how to get started and build your own deep learning convolutional neural network. Step 1 Step 2 Project Website Check out our website here for more information about our project.","title":"Build Your Own"},{"location":"build_your_own/#build-your-own-dcnn","text":"The following document describes how to get started and build your own deep learning convolutional neural network.","title":"Build Your Own DCNN"},{"location":"build_your_own/#step-1","text":"","title":"Step 1"},{"location":"build_your_own/#step-2","text":"","title":"Step 2"},{"location":"build_your_own/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"hardware/","text":"Hardware Architecture The following outlines hardware specifications, block diagrams, pseudo code along with the results and analysis of the design. Code can start below in this format: mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Project Website Check out our website here for more information about our project.","title":"Hardware"},{"location":"hardware/#hardware-architecture","text":"The following outlines hardware specifications, block diagrams, pseudo code along with the results and analysis of the design.","title":"Hardware Architecture"},{"location":"hardware/#code-can-start-below-in-this-format","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Code can start below in this format:"},{"location":"hardware/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"software/","text":"Software Architecture The following outlines software specifications, block diagrams, pseudo code and important results and analysis for the project. Software specifications Item Value Input image filetype All OpenCV() supported (.jpg, .png, etc) Input kernel data filetype .csv file Output data filetype .jpg image Supported OS Linux Preprocessors Im_load_stream This script takes in the image and kernel, converting to fixed point (originally floating point) sends the data to FPGA via Powershell Serial Interface Project Website Check out our website here for more information about our project.","title":"Software"},{"location":"software/#software-architecture","text":"The following outlines software specifications, block diagrams, pseudo code and important results and analysis for the project.","title":"Software Architecture"},{"location":"software/#software-specifications","text":"Item Value Input image filetype All OpenCV() supported (.jpg, .png, etc) Input kernel data filetype .csv file Output data filetype .jpg image Supported OS Linux","title":"Software specifications"},{"location":"software/#preprocessors","text":"","title":"Preprocessors"},{"location":"software/#im_load_stream","text":"This script takes in the image and kernel, converting to fixed point (originally floating point) sends the data to FPGA via Powershell","title":"Im_load_stream"},{"location":"software/#serial-interface","text":"","title":"Serial Interface"},{"location":"software/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"verification/","text":"Verification The following outlines verification of the software-hardware emulation. Hardware emulation is a tool for hardware/software co-verification and integration testing. Baby Yoda was the first image successfully tested. Emulation Originally the emulation that was built had packaging issues, so a more efficient method was created in python. This design offers users a python interface; simply give the PC an image and kernel size, MATLAB is called. The output is acquired from MATLAB and the actual value can be calculated. Conv_tester Originally, this was written in MATLAB; however, it was rewritten in Python. This MATLAB-based implementation is called and our FPGA Convolution algorithm performs image filtering. This script loads an image and a kernel, preprocesses them, and then calls the MATLAB-based implementation of our FPGA Convolution algorithm to perform image filtering. The results are validated using SciPy, and asserts. For thorough testing, we loaded in 1000 images from the CIFAR-10 image dataset. Import Libraries Conversion to Greyscale The user provides the script with dimensions and metrics, it takes in an image, which is converted to greyscale. Verify with MATLAB Output Computes the ground truth correlation and checks the MATLAB output for similarity based on a tolerance. Load Image, Preprocesses and Zero Pads Exporting to MATLAB The first lines generates the edge detection kernel. The image and array is saved to text files. Finally, the image and kernel arrays are loaded into MATLAB. Test the FPGA Convolution Algorithm The script will call FPGA_Runner.m from MATLAB to test the algorithm. Pass/Fail Test \"True\" when the convolution passes, and \"False\" when the convolution from MATLAB does not match the SciPy convolution. The system will check if it matches a true convolution; if it outputs valid the test passed, while invalid indicates that the test failed. Note that if the script fails at any of the images, the loop will stop. Project Website Check out our website here for more information about our project.","title":"Verification"},{"location":"verification/#verification","text":"The following outlines verification of the software-hardware emulation. Hardware emulation is a tool for hardware/software co-verification and integration testing. Baby Yoda was the first image successfully tested.","title":"Verification"},{"location":"verification/#emulation","text":"Originally the emulation that was built had packaging issues, so a more efficient method was created in python. This design offers users a python interface; simply give the PC an image and kernel size, MATLAB is called. The output is acquired from MATLAB and the actual value can be calculated.","title":"Emulation"},{"location":"verification/#conv_tester","text":"Originally, this was written in MATLAB; however, it was rewritten in Python. This MATLAB-based implementation is called and our FPGA Convolution algorithm performs image filtering. This script loads an image and a kernel, preprocesses them, and then calls the MATLAB-based implementation of our FPGA Convolution algorithm to perform image filtering. The results are validated using SciPy, and asserts. For thorough testing, we loaded in 1000 images from the CIFAR-10 image dataset.","title":"Conv_tester"},{"location":"verification/#import-libraries","text":"","title":"Import Libraries"},{"location":"verification/#conversion-to-greyscale","text":"The user provides the script with dimensions and metrics, it takes in an image, which is converted to greyscale.","title":"Conversion to Greyscale"},{"location":"verification/#verify-with-matlab-output","text":"Computes the ground truth correlation and checks the MATLAB output for similarity based on a tolerance.","title":"Verify with MATLAB Output"},{"location":"verification/#load-image-preprocesses-and-zero-pads","text":"","title":"Load Image, Preprocesses and Zero Pads"},{"location":"verification/#exporting-to-matlab","text":"The first lines generates the edge detection kernel. The image and array is saved to text files. Finally, the image and kernel arrays are loaded into MATLAB.","title":"Exporting to MATLAB"},{"location":"verification/#test-the-fpga-convolution-algorithm","text":"The script will call FPGA_Runner.m from MATLAB to test the algorithm.","title":"Test the FPGA Convolution Algorithm"},{"location":"verification/#passfail-test","text":"\"True\" when the convolution passes, and \"False\" when the convolution from MATLAB does not match the SciPy convolution. The system will check if it matches a true convolution; if it outputs valid the test passed, while invalid indicates that the test failed. Note that if the script fails at any of the images, the loop will stop.","title":"Pass/Fail Test"},{"location":"verification/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"}]}