{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Convolutional Neural Network Accelerator This document describes the architecture and implementation for an end-to-end 2D convolution acceleration system, targeting applications such as image filtering and deep convolutional neural networks. The goal of such is to provide readers with the necessary explanations and resources to understand the concepts in our design. High Level Block Diagram Project Overview Deep Convolutional Neural Networks (DCNNs) have made significant progress in approaching a wide range of problems in the general area of computer vision. However, they generally require enormous computational resources and are therefore difficult to deploy in real-time systems. To address this problem, we designed a system for accelerating the core operations required by DCNNs, by using a low-cost Field Programmable Gate Array (FPGA) platform. Our team designed an end-to-end accelerator platform, including a PC running Linux, an FPGA board and PC-to-FPGA communication via serial data (over USB). We designed a hardwired convolution processor using custom fixed-point multipliers, and a software handler for sending and reconstructing images. Using custom Verilog/VHDL RTL descriptions and C# software, we aim to exploit the parallelism inherent to FPGAs for high-speed acceleration. FPGAs are inexpensive pieces of hardware, and if our design is successful, it can be used by anyone. Project Website Check out our website here for more information about our project.","title":"Home"},{"location":"#convolutional-neural-network-accelerator","text":"This document describes the architecture and implementation for an end-to-end 2D convolution acceleration system, targeting applications such as image filtering and deep convolutional neural networks. The goal of such is to provide readers with the necessary explanations and resources to understand the concepts in our design.","title":"Convolutional Neural Network Accelerator"},{"location":"#high-level-block-diagram","text":"","title":"High Level Block Diagram"},{"location":"#project-overview","text":"Deep Convolutional Neural Networks (DCNNs) have made significant progress in approaching a wide range of problems in the general area of computer vision. However, they generally require enormous computational resources and are therefore difficult to deploy in real-time systems. To address this problem, we designed a system for accelerating the core operations required by DCNNs, by using a low-cost Field Programmable Gate Array (FPGA) platform. Our team designed an end-to-end accelerator platform, including a PC running Linux, an FPGA board and PC-to-FPGA communication via serial data (over USB). We designed a hardwired convolution processor using custom fixed-point multipliers, and a software handler for sending and reconstructing images. Using custom Verilog/VHDL RTL descriptions and C# software, we aim to exploit the parallelism inherent to FPGAs for high-speed acceleration. FPGAs are inexpensive pieces of hardware, and if our design is successful, it can be used by anyone.","title":"Project Overview"},{"location":"#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"about/","text":"More Information For more information about neural networks, convolutions, and the future of artificial intelligence, check out some of the resources below. A Comprehensive Guide to Convolutional Neural Networks This easy to follow guide provides helpful visuals and description about the main components of convolutional neural networks. Machine Learning Guide Hosted through a GitHub repository, this site provides brief visual explanations of machine learning concepts with diagrams, code examples and links to other resources. Project Website Check out our website here for more information about our project.","title":"About"},{"location":"about/#more-information","text":"For more information about neural networks, convolutions, and the future of artificial intelligence, check out some of the resources below.","title":"More Information"},{"location":"about/#a-comprehensive-guide-to-convolutional-neural-networks","text":"This easy to follow guide provides helpful visuals and description about the main components of convolutional neural networks.","title":"A Comprehensive Guide to Convolutional Neural Networks"},{"location":"about/#machine-learning-guide","text":"Hosted through a GitHub repository, this site provides brief visual explanations of machine learning concepts with diagrams, code examples and links to other resources.","title":"Machine Learning Guide"},{"location":"about/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"build_your_own/","text":"Build Your Own DCNN The following document describes how to get started and build your own deep learning convolutional neural network. Step 1 Download the folder from GitHub and extract the zip. (Which folder ask ryan) Step 2 Open powershell and run: $env:PATH = $env:PATH + \";C:\\Xilinx\\Vivado\\2018.2\\bin\" This adds Vivado to the environment path and runs Vivado. Step 3 Run echo $env:PATH Ensure that vivado is added into the environment path Step 4 cd C:\\Users\\user\\Downloads\\518\\BUILD Change directory into downloaded folder Step 5 vivado -mode tcl Opens up Vivado in tcl mode Step 6 In vivado tcl mode run: source top.tcl This builds the entire project for 518 x 518 image convolution (The real image size is 512 x 512 with 0 padding). Project Website Check out our website here for more information about our project.","title":"Build Your Own"},{"location":"build_your_own/#build-your-own-dcnn","text":"The following document describes how to get started and build your own deep learning convolutional neural network.","title":"Build Your Own DCNN"},{"location":"build_your_own/#step-1","text":"Download the folder from GitHub and extract the zip. (Which folder ask ryan)","title":"Step 1"},{"location":"build_your_own/#step-2","text":"Open powershell and run: $env:PATH = $env:PATH + \";C:\\Xilinx\\Vivado\\2018.2\\bin\" This adds Vivado to the environment path and runs Vivado.","title":"Step 2"},{"location":"build_your_own/#step-3","text":"Run echo $env:PATH Ensure that vivado is added into the environment path","title":"Step 3"},{"location":"build_your_own/#step-4","text":"cd C:\\Users\\user\\Downloads\\518\\BUILD Change directory into downloaded folder","title":"Step 4"},{"location":"build_your_own/#step-5","text":"vivado -mode tcl Opens up Vivado in tcl mode","title":"Step 5"},{"location":"build_your_own/#step-6","text":"In vivado tcl mode run: source top.tcl This builds the entire project for 518 x 518 image convolution (The real image size is 512 x 512 with 0 padding).","title":"Step 6"},{"location":"build_your_own/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"hardware/","text":"Hardware Architecture The following outlines hardware specifications, block diagrams, pseudo code along with the results and analysis of the design. High Level Block and Diagram Hardware Specifications FPGA Nexys DDR board with Xilinx Artix-7 chip 160 18-bit DSP slices (up to 16 GOPs throughput at 100 MHz) 0.5 Mbytes of block RAM UART Block Item Value Data Input Rate 100 kBps Data Output Rate 100 kBps Baud Rate 1 Mbps Data Transfer Interface UART over USB Convolution Block Items Committed Requirement Stretch Goal Input Image Size 512x512 4096x4096 # of input planes 3 Arbitrary Output image size Valid Same, valid, full # of output planes 3 Arbitrary Kernel Size 7x7 Arbitrary, where W * H * D < 512 Same, Full, Valid Same: The output image is the same size as the input image (fxf) Full: The output image is larger than the input image ((f+g) x (f+g)) Valid: The output image is smaller than the input image ((f-g/2) x (f-g/2)) FPGA Block Diagram Example of ILB with Image Window Add Description of the animation Project Website Check out our website here for more information about our project.","title":"Hardware"},{"location":"hardware/#hardware-architecture","text":"The following outlines hardware specifications, block diagrams, pseudo code along with the results and analysis of the design.","title":"Hardware Architecture"},{"location":"hardware/#high-level-block-and-diagram","text":"","title":"High Level Block and Diagram"},{"location":"hardware/#hardware-specifications","text":"","title":"Hardware Specifications"},{"location":"hardware/#fpga","text":"Nexys DDR board with Xilinx Artix-7 chip 160 18-bit DSP slices (up to 16 GOPs throughput at 100 MHz) 0.5 Mbytes of block RAM","title":"FPGA"},{"location":"hardware/#uart-block","text":"Item Value Data Input Rate 100 kBps Data Output Rate 100 kBps Baud Rate 1 Mbps Data Transfer Interface UART over USB","title":"UART Block"},{"location":"hardware/#convolution-block","text":"Items Committed Requirement Stretch Goal Input Image Size 512x512 4096x4096 # of input planes 3 Arbitrary Output image size Valid Same, valid, full # of output planes 3 Arbitrary Kernel Size 7x7 Arbitrary, where W * H * D < 512","title":"Convolution Block"},{"location":"hardware/#same-full-valid","text":"Same: The output image is the same size as the input image (fxf) Full: The output image is larger than the input image ((f+g) x (f+g)) Valid: The output image is smaller than the input image ((f-g/2) x (f-g/2))","title":"Same, Full, Valid"},{"location":"hardware/#fpga-block-diagram","text":"","title":"FPGA Block Diagram"},{"location":"hardware/#example-of-ilb-with-image-window","text":"Add Description of the animation","title":"Example of ILB with Image Window"},{"location":"hardware/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"software/","text":"Software Architecture The following outlines software specifications, block diagrams, pseudo code and important results and analysis for the project. High Level Block Diagram Software Specifications Item Value Input image filetype All OpenCV() supported (.jpg, .png, etc) Input kernel data filetype .csv file Output data filetype .jpg image Supported OS Windows Preprocessors Discuss Preprocessors (might not be necessary) Im_load_stream This script takes in the image and kernel, converting such to fixed point (originally floating point) and sends the data to the FPGA via Powershell. Serial Interface FPGA Read Write Process - Load bytes into local bytes array - Stream to FPGA using port.write() - Read in serial input buffer using ReadAvailable() Project Website Check out our website here for more information about our project.","title":"Software"},{"location":"software/#software-architecture","text":"The following outlines software specifications, block diagrams, pseudo code and important results and analysis for the project.","title":"Software Architecture"},{"location":"software/#high-level-block-diagram","text":"","title":"High Level Block Diagram"},{"location":"software/#software-specifications","text":"Item Value Input image filetype All OpenCV() supported (.jpg, .png, etc) Input kernel data filetype .csv file Output data filetype .jpg image Supported OS Windows","title":"Software Specifications"},{"location":"software/#preprocessors","text":"Discuss Preprocessors (might not be necessary)","title":"Preprocessors"},{"location":"software/#im_load_stream","text":"This script takes in the image and kernel, converting such to fixed point (originally floating point) and sends the data to the FPGA via Powershell.","title":"Im_load_stream"},{"location":"software/#serial-interface","text":"FPGA Read Write Process - Load bytes into local bytes array - Stream to FPGA using port.write() - Read in serial input buffer using ReadAvailable()","title":"Serial Interface"},{"location":"software/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"},{"location":"verification/","text":"Verification The following outlines verification of the software-hardware emulation. Hardware emulation is a tool for hardware/software co-verification and integration testing. Baby Yoda was the first image successfully tested (using 512x512 dimensions). Overview Emulation Originally the emulation that was built had packaging issues, so a more efficient method was created in python. This design offers users a Python interface; simply give the PC an image and kernel size, MATLAB is called. The output is acquired from MATLAB and the actual value can be calculated. Conv_tester Originally, this was written in MATLAB; however, it was rewritten in Python. This MATLAB-based implementation is called and our FPGA Convolution algorithm performs image filtering. This script loads an image and a kernel, preprocesses them, and then calls the MATLAB-based implementation of our FPGA Convolution algorithm to perform image filtering. The results are validated using SciPy, and asserts. For thorough testing, we loaded in 1000 images from the CIFAR-10 image dataset. Import Libraries Conversion to Greyscale The user provides the script with dimensions and metrics, it takes in an image, which is converted to greyscale. Verify with MATLAB Output Computes the ground truth correlation and checks the MATLAB output for similarity based on a tolerance. Load Image, Preprocesses and Zero Pads Exporting to MATLAB The first lines generates the edge detection kernel. The image and array is saved to text files. Finally, the image and kernel arrays are loaded into MATLAB. Test the FPGA Convolution Algorithm The script will call FPGA_Runner.m from MATLAB to test the algorithm. Pass/Fail Test \"True\" when the convolution passes, and \"False\" when the convolution from MATLAB does not match the SciPy convolution. The system will check if it matches a true convolution; if it outputs valid the test passed, while invalid indicates that the test failed. Note that if the script fails at any of the images, the loop will stop. Project Website Check out our website here for more information about our project.","title":"Verification"},{"location":"verification/#verification","text":"The following outlines verification of the software-hardware emulation. Hardware emulation is a tool for hardware/software co-verification and integration testing. Baby Yoda was the first image successfully tested (using 512x512 dimensions).","title":"Verification"},{"location":"verification/#overview","text":"","title":"Overview"},{"location":"verification/#emulation","text":"Originally the emulation that was built had packaging issues, so a more efficient method was created in python. This design offers users a Python interface; simply give the PC an image and kernel size, MATLAB is called. The output is acquired from MATLAB and the actual value can be calculated.","title":"Emulation"},{"location":"verification/#conv_tester","text":"Originally, this was written in MATLAB; however, it was rewritten in Python. This MATLAB-based implementation is called and our FPGA Convolution algorithm performs image filtering. This script loads an image and a kernel, preprocesses them, and then calls the MATLAB-based implementation of our FPGA Convolution algorithm to perform image filtering. The results are validated using SciPy, and asserts. For thorough testing, we loaded in 1000 images from the CIFAR-10 image dataset.","title":"Conv_tester"},{"location":"verification/#import-libraries","text":"","title":"Import Libraries"},{"location":"verification/#conversion-to-greyscale","text":"The user provides the script with dimensions and metrics, it takes in an image, which is converted to greyscale.","title":"Conversion to Greyscale"},{"location":"verification/#verify-with-matlab-output","text":"Computes the ground truth correlation and checks the MATLAB output for similarity based on a tolerance.","title":"Verify with MATLAB Output"},{"location":"verification/#load-image-preprocesses-and-zero-pads","text":"","title":"Load Image, Preprocesses and Zero Pads"},{"location":"verification/#exporting-to-matlab","text":"The first lines generates the edge detection kernel. The image and array is saved to text files. Finally, the image and kernel arrays are loaded into MATLAB.","title":"Exporting to MATLAB"},{"location":"verification/#test-the-fpga-convolution-algorithm","text":"The script will call FPGA_Runner.m from MATLAB to test the algorithm.","title":"Test the FPGA Convolution Algorithm"},{"location":"verification/#passfail-test","text":"\"True\" when the convolution passes, and \"False\" when the convolution from MATLAB does not match the SciPy convolution. The system will check if it matches a true convolution; if it outputs valid the test passed, while invalid indicates that the test failed. Note that if the script fails at any of the images, the loop will stop.","title":"Pass/Fail Test"},{"location":"verification/#project-website","text":"Check out our website here for more information about our project.","title":"Project Website"}]}